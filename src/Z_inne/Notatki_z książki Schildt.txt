Herbert Schildt - JAVA. Przewodnik dla pocz¹tkuj¹cych
MOJE NOTATKI


Lekcja 5
metody, metody zwracaj¹ce wartoœæ
Jeœli stworzymy dwie metody o tej samej nazwie ale ró¿nych typach (np. int i float) a potem wywo³amy nazwê tej metody to zostanie wywo³ana ta metoda której zgadza siê typ przekazywanego argumentu. 

Klasy piszemy z wielkiej litery, metody i zmienne - z ma³ej.

W Javie mo¿emy dziedziczyæ tylko po jednej klasie nadrzêdne. Nie ma wielodziedziczenia. Nie mo¿na zapisaæ: "public class Dog extends klasa1, klasa2"

private - dostêpne tylko w tej klesie
public - dostêpne w ca³ym projekcie
protected - dostêpne w klasach pochodnych i klasach z tego pakietu 
nic - modyfikator domyœlny - dostêpne w klasach z tego samego pakietu


Wyr1 ? Wyr2 : Wyr3   
SprawdŸ Wyr 1, jeœli jest Wyr1=true to wykonaj Wyr2, jeœli Wyr1=false to wykonaj wyr3
_________________________

Rozdz.6 Wiêcej o metodach i klasach
Jeœli przy klasie nie ma modyfikatora dostêpu to wtedy jest domyœlny: public.

Argumenty metodom mo¿na przekazywaæ przez wartoœæ lub przez referencjê (str.165). Raz Ÿród³o siê modyfikuje( przez wartoœæ) a raz nie (przez referencjê).
Jako argumenty mo¿na przekazywaæ te¿ obiekty. Metody mog¹ równie¿ zwracaæ obiekty jako wynik (return)

Przeci¹¿anie metod - Dwie lub wiêcej metod w tej samej klasie mo¿e mieæ t¹ sam¹ nazwê a ró¿ni¹ siê tylko deklaracjami parametrów. Nie wystarczy, ¿e bêd¹ siê ró¿niæ tylko zwracanym typem. Mo¿e wyst¹piæ konwersja typów(str. 170). Dziêki temu jedna metoda mo¿e realizowaæ dzia³ania dla ró¿nych typów danych wejœciowych. Nie trzeba dla ka¿dego typu pisaæ oddzielnej metody.
Sygnatura - tak nazywamy metodê wraz z list¹ jej parametrów. Bez typu zwracanego przez metodê.
Mo¿na te¿ przeci¹¿aæ konstruktory.

Rekurencja - metoda wywo³uje sam¹ siebie. Musi zawieraæ jakiœ warunek aby jeden przebieg programu by³ bez rekurencji aby program siê nie zapêtli³ na sta³e.

Static - jeœli klasa jest static to mo¿na u¿ywaæ jej zanim zadeklarujemy pierwszy obiekt tej klasy

Algorytm Quicksort - sortowanie tablicy szybsze ni¿ b¹belkowe

Klasy zagnie¿d¿one - klasy zadeklarowane wewn¹trz innej klasy.
Klasy wewnêtrzne - rodzaj klas zagnie¿d¿onych w których nie u¿yto s³owa static.

Zmienne liczby argumentów (...)

_________________________
Rozdz. 7 Dziedziczenie

Ogólna postaæ: class klasa-pochodna extends klasa-bazowa{...cia³o klasy...}
Klasa pochodna mo¿e dziedziczyæ tylko po jednej klasie bazowej ( w przeciwieñstwie do jêzyka C+)
Hierarchia dziedziczenia - Klasa pochodna mo¿e byæ klas¹ bazowa dla innej klasy.
Klasa pochodna nie ma dostêpu do sk³adowych klasy bazowej oznaczonych jako private.

Konstruktor klasy bazowej tworzy tê czêœæ obiektu któr¹ definiuje klasa bazowa, a 
konstruktor klasy pochodnej tworzy tê czêœæ obiektu któr¹ definiuje klasa pochodna.

Super - s³owo kluczowe. ma dwa zastosowania:
1. Wywo³anie konstruktora klasy bazowej
super(lista-parametrów) - wywo³anie konstruktora klasy bazowej - musi zawsze wystêpowaæ na pocz¹tku konstruktora klasy pochodnej.

2. Dostêp do sk³adowych klasy bazowej przes³oniêtych przez sk³adow¹ klasy pochodnej. (str.203)
postaæ ogólna: super.sk³adowa     - sk³adowa mo¿e byæ zmienn¹ lub metod¹. U¿ywamy gdy nazwa sk³adowej klasy pochodnej przes³ania tak¹ sam¹ nazwê klasy bazowej.

Najpierw wykonywany jest konstruktor klasy bazowej a potem konstruktory klas coraz bardziej pochodnych (str.208)

Referencje klasy bazowej i obiekty klasy pochodnej, czyli co mo¿na przypisywaæ do czego (str.209)

Przes³anianie metod.
Klasa pochodna mo¿e mieæ tak¹ sam¹ metodê jak klasa bazowa (ten sam zwracany typ i ta sama sygnatura). Wywo³anie takiej metody w klasie pochodnej spowoduje wywo³anie metody zdefiniowanej w klasie pochodnej. Aby wywo³aæ przys³oniet¹ metodê z klasy bazowej nale¿y u¿yæ s³owa super, czyli: "super.nazwa_metody()".

Nie mylmy przes³aniania z przeci¹¿aniem.
Metody przes³oniête - taka sama sygnatura (nazwa + argumenty)
Metody przeci¹¿one - taka sama nazwa metody.

Polimorfizm

Klasy abstrakcyjne (str. 220)
U¿ywamy dla klas, które musz¹ byæ przes³oniete w klasach pochodnych bo same nie maj¹ odpowiedniej treœci.
abstract typ nazwaMetody(lista-parametrow); (metoda ta nie ma cia³a, czyli tego co w nawiasach klamrowych{})
nie mo¿na tworzyæ obiektów klasy abstrakcyjnej, obiekty mog¹ byæ tworzone z klasy pochodnej po tej bazowej abstrakcyjnej.

Final - u¿ycie go przy klasie lub metodzie blokuje mo¿liwoœc tworzenia i klas, metod pochodnych (str. 223)

Klasa Object - zdefiniowana domyœlnie w javie klasa bazowa wszystkich innych klas. (str.225)


_________________________
Rozdz. 8 Pakiety i interfejsy (str. 227)

Pakiety - grupy powi¹zanych klas. Pomagaja organizowaæ kod i tworz¹ kolejn¹ warstwê hermetyzacji.
Interfejs - definiuje zbiór metod, które zostan¹ zaimplementowane przez klasê.

Pakiety umo¿liwiaj¹ podzia³ przestrzeni nazw. Klasy w tym samym projekcie a w ró¿nych pakietach mog¹ mieæ t¹ sam¹ nazwê.
ogólna postaæ: package nazwa-pakietu
Ka¿dy pakiet tworzy oddzielny katalog na dysku w którym zapisywane s¹ pliki nale¿ace do tego pakietu.
Pakiety mo¿na zagnie¿d¿aæ, zagnie¿d¿aj¹ siê wtedy te¿ katalogi.
np. package pakiet1.pakiet2.pakiet3;

Tabel dostêpnoœci (str.231) public, private, protected...

S³owo import
import pakiet.klasa 
import pakiet.*    - ca³a zawartoœæ pakietu                                                                                                                                                             

Przyk³ad wbudowanych pakietów Java (str. 235)
java.lang - ten pakiet jest automatycznie importowany do ka¿dego programu w javie. Inne trzeba importowaæ samemu (s³owem import)


Interfejs (str. 235) - Zbiór deklaracji metod i zmiennych bez cia³a, abstrakcyjnych
dostêp interface nazwa{....}

Aby zaimplementowaæ interfejs u¿ywamy s³owa implements
class nazwaKlasy extends klasaBazowa implements nazwaInterfejsu{....}		//extends klasaBazowa - element opcjonalny
zmienne i metody od interfejsu musz¹ byæ public.
Interfejsy mog¹ dzidziczyc po innych interfejsach

Metoda domyœlna (str. 246) - default, stosujemy w interfejsie. Jesli zawiera domyœln¹ implementacjê nie trzeba jej póŸniej przes³aniaæ.


_________________________
Rozdz. 9 Obs³uga wyj¹tków (str. 253)

Podstawowe s³owa kluczowe: try, catch, throw, throws, finally
try{monitorowany kod}
catch (typWyj¹tku1 obiektWyj¹tku){obs³uga dla typu wyj¹tku nr 1 }
catch (typWyj¹tku2 obiektWyj¹tku){obs³uga dla typu wyj¹tku nr 2 }

obiektWyj¹tku - obiekt przekazywany do klauzuli catch (w ksi¹¿ce" exc, nale¿y do klasy throwable, ma swoje metody) po przechwyceniu przez ni¹ wyj¹tku
Monitorowanie odbywa siê w ca³ym kodzie zawartym w bloku try. Monitorowana te¿ jest zawartoœæ metod wywo³anych w try.
Pêtle try mo¿na zagnie¿d¿aæ.

Wyj¹tek mo¿emy utworzyæ sami instrukcj¹ throw (str. 262)
throw new nazwaWyj¹tku();
Throw mo¿e te¿ s³u¿yæ do ponownego wygenerowania wyj¹tku po jego wczeœniejszej obs³udze przez catch (¿eby inne catch mog³o go jeszcze obs³u¿yæ). Wtedy u¿ywamy te¿ rethrow dla nowego try.

Nie trzeba dawaæ try do g³ównego kodu. Mo¿na zrobiæ oddzielny blok zajmuj¹cy siê tylko obs³ug¹ b³êdów (str. 264 list 9.11)

finally (str. 265) - s³owem tym oznaczamy blok kodu który ma siê wykonaæ po zakoñczeniu wykonywania tego co w catch. Rozumiem, ¿e jak nie bêdzie b³edu to catch nie zadzia³a i finally siê nie wykona (jednak chyba zawsze siê wykona niezale¿nie czy b³¹d zaszed³).

throws (str. 266) - u¿ywamy gdy wyj¹tek trzeba zadeklarowaæ razem z metod¹

Jedno catch mo¿e przechwytywaæ kilka ró¿nych wyj¹tków. Wyj¹tki ³¹czy siê wtedy symbolem "|"

Wyjatki wbudoawane w Javê, niesprawdzane i sprawdzane, tabela. (str. 269)
£añcuchy wyj¹tków (gdy jeden wyjatek jest spowodowany przez inny.)

Tworzenie klas pochodnych wyj¹tków (gdy chce siê zrobiæ swój w³asny wyj¹tek).

_________________________
Rozdz. 10 Obs³uga wejœcia i wyjœcia (str. 275)
Strumienie bajtowe (InputStream, OutputStream)
Strumienie znakowe (Reader, Writer)

Odczyt z pliku (str. 281)
Zapis do pliku (str. 284)

catch (IOException exc) - IOException jest bazowy dla szczegó³owych wyj¹tków wejscia-wyjœcia wiêc mo¿na u¿ywaæ jego jednego zamiast kilku podrzêdnych.

try bez close - (str. 286) nowy sposób wywo³ywania try
Mozna zapisywaæ-odczytywaæ z pliku sekwencyjnie albo u¿yæ RandomAccessFile.

U¿ywanie printWriter zamiast sout (str. 297). (do profesjopnalnych zastosowañ lepsze od sout.

Klasy opakowuj¹ce - konwersja wczytanego np. z klawiatury formatu na inny.